// C·∫≠p nh·∫≠t c√°c service kh√°c: OrderService, PaymentService, CartService
// (ƒë√£ s·ª≠a t√™n c·ªôt theo chu·∫©n database: id, id_SanPham, id_NguoiDung, ...)

const db = require("../config/database");
// ‚ùå B·ªé: const InventoryService = require("./inventory.service");
const emailService = require("./email.service");

class OrderService {
  async createOrder(orderData, userId = null, sessionId = null) {
    const connection = await db.getConnection();

    try {
      await connection.beginTransaction();

      // Frontend g·ª≠i format v·ªõi field names ƒë√∫ng
      const {
        hoTen,
        email,
        diaChiGiao,
        soDienThoai,
        id_ThanhToan, // ‚úÖ Fixed: match database field name
        id_VanChuyen,
        MaGiamGia,
        ghiChu,
        tongTien,
        tongTienSauGiam,
        phiVanChuyen,
        sessionId: frontendSessionId, // In case sessionId is sent in body
      } = orderData;

      // Use sessionId from parameter or from body
      const finalSessionId = sessionId || frontendSessionId;

      // Validate required fields
      if (!hoTen || !email || !diaChiGiao || !soDienThoai) {
        throw new Error("Thi·∫øu th√¥ng tin b·∫Øt bu·ªôc");
      }

      // C·∫£i thi·ªán validation cho payment v√† shipping methods
      const paymentMethodId = parseInt(id_ThanhToan);
      const shippingMethodId = parseInt(id_VanChuyen);

      if (!id_ThanhToan || isNaN(paymentMethodId) || paymentMethodId <= 0) {
        throw new Error(
          "Thi·∫øu th√¥ng tin ph∆∞∆°ng th·ª©c thanh to√°n ho·∫∑c kh√¥ng h·ª£p l·ªá"
        );
      }

      if (!id_VanChuyen || isNaN(shippingMethodId) || shippingMethodId <= 0) {
        throw new Error(
          "Thi·∫øu th√¥ng tin ph∆∞∆°ng th·ª©c v·∫≠n chuy·ªÉn ho·∫∑c kh√¥ng h·ª£p l·ªá"
        );
      }

      // Ki·ªÉm tra xem ph∆∞∆°ng th·ª©c thanh to√°n c√≥ t·ªìn t·∫°i kh√¥ng
      const [paymentMethod] = await connection.execute(
        "SELECT id FROM hinhthucthanhtoan WHERE id = ? AND TrangThai = 1",
        [paymentMethodId]
      );
      if (paymentMethod.length === 0) {
        throw new Error(
          "Ph∆∞∆°ng th·ª©c thanh to√°n kh√¥ng t·ªìn t·∫°i ho·∫∑c ƒë√£ b·ªã v√¥ hi·ªáu h√≥a"
        );
      }

      // 1. L·∫•y gi·ªè h√†ng
      let cartQuery, cartParams;
      if (userId) {
        cartQuery = `
          SELECT gh.*, ctsp.id_SanPham, sp.Gia, sp.GiaKhuyenMai
          FROM giohang gh
          JOIN chitietsanpham ctsp ON gh.id_ChiTietSanPham = ctsp.id
          JOIN sanpham sp ON ctsp.id_SanPham = sp.id
          WHERE gh.id_NguoiDung = ?`;
        cartParams = [userId];
      } else if (sessionId) {
        cartQuery = `
          SELECT gh.*, ctsp.id_SanPham, sp.Gia, sp.GiaKhuyenMai
          FROM giohang gh
          JOIN chitietsanpham ctsp ON gh.id_ChiTietSanPham = ctsp.id
          JOIN sanpham sp ON ctsp.id_SanPham = sp.id
          WHERE gh.session_id = ? AND gh.id_NguoiDung IS NULL`;
        cartParams = [sessionId];
      } else {
        throw new Error("Thi·∫øu th√¥ng tin ng∆∞·ªùi d√πng ho·∫∑c session");
      }

      // Debugging logs to verify session and cart query
      console.log("üîç Debug - sessionId:", sessionId);
      console.log("üîç Debug - userId:", userId);

      const [cartItems] = await connection.execute(cartQuery, cartParams);

      // Debug log k·∫øt qu·∫£ gi·ªè h√†ng
      console.log("üîç Debug - cartItems count:", cartItems.length);
      console.log("üîç Debug - cartItems:", cartItems);

      if (cartItems.length === 0) {
        throw new Error("Gi·ªè h√†ng tr·ªëng");
      }

      // ‚úÖ S·ª¨A: 2. Ki·ªÉm tra t·ªìn kho b·∫±ng database functions thay v√¨ c·ªôt TonKho
      for (const item of cartItems) {
        const [stockCheck] = await connection.execute(
          `SELECT 
            fn_TinhTonKhoRealTime(?) as TonKhoThucTe,
            fn_CoTheBan(?, ?) as CoTheBan
          `,
          [item.id_ChiTietSanPham, item.id_ChiTietSanPham, item.SoLuong]
        );

        if (stockCheck.length === 0 || stockCheck[0].CoTheBan !== 1) {
          throw new Error(
            `S·∫£n ph·∫©m trong gi·ªè h√†ng kh√¥ng ƒë·ªß s·ªë l∆∞·ª£ng t·ªìn kho. T·ªìn kho th·ª±c t·∫ø: ${
              stockCheck[0]?.TonKhoThucTe || 0
            }, y√™u c·∫ßu: ${item.SoLuong}`
          );
        }
      }

      // 3. T√≠nh t·ªïng ti·ªÅn (∆∞u ti√™n GiaKhuyenMai theo nghi·ªáp v·ª• web b√°n gi√†y)
      let TongTienHang = cartItems.reduce((sum, item) => {
        const finalPrice = item.GiaKhuyenMai || item.Gia;
        return sum + finalPrice * item.SoLuong;
      }, 0);

      // 4. √Åp d·ª•ng m√£ gi·∫£m gi√° (n·∫øu c√≥)
      let GiamGia = 0;
      if (MaGiamGia) {
        const [vouchers] = await connection.execute(
          `SELECT * FROM magiamgia 
           WHERE Ma = ? 
           AND NgayBatDau <= NOW() 
           AND NgayKetThuc >= NOW()
           AND SoLuotSuDung - SoLuotDaSuDung > 0`,
          [MaGiamGia]
        );
        if (vouchers.length > 0) {
          const voucher = vouchers[0];
          if (TongTienHang >= voucher.DieuKienApDung) {
            GiamGia = Math.min(
              (TongTienHang * voucher.PhanTramGiam) / 100,
              voucher.GiaTriGiamToiDa
            );
            await connection.execute(
              `UPDATE magiamgia SET SoLuotDaSuDung = SoLuotDaSuDung + 1 WHERE Ma = ?`,
              [MaGiamGia]
            );
          }
        }
      }

      // 5. T√≠nh ph√≠ v·∫≠n chuy·ªÉn
      const [shippingMethod] = await connection.execute(
        `SELECT PhiVanChuyen FROM hinhthucvanchuyen WHERE id = ?`,
        [id_VanChuyen]
      );
      if (shippingMethod.length === 0) {
        throw new Error("H√¨nh th·ª©c v·∫≠n chuy·ªÉn kh√¥ng h·ª£p l·ªá");
      }
      const PhiVanChuyen = shippingMethod[0].PhiVanChuyen || 0;

      // 6. T√≠nh t·ªïng thanh to√°n
      const TongThanhToan = TongTienHang - GiamGia + PhiVanChuyen;

      // 7. T·∫°o ƒë∆°n h√†ng v·ªõi field name ƒë√∫ng
      // --- S·ª≠a: sinh m√£ ƒë∆°n h√†ng tr∆∞·ªõc khi insert ---
      const today = new Date();
      const dateStr = today.toISOString().slice(2, 10).replace(/-/g, ""); // YYMMDD
      // Insert t·∫°m, sau ƒë√≥ update l·∫°i MaDonHang chu·∫©n
      const [orderResult] = await connection.execute(
        `INSERT INTO donhang (
    MaDonHang, id_NguoiMua, NgayDatHang, TongTienHang, GiamGia, PhiVanChuyen, 
    TongThanhToan, DiaChiNhan, SDTNguoiNhan, TenNguoiNhan, EmailNguoiNhan,
    TrangThai, id_ThanhToan, id_VanChuyen, MaGiamGia, GhiChu, session_id
  ) VALUES (?, ?, NOW(), ?, ?, ?, ?, ?, ?, ?, ?, 1, ?, ?, ?, ?, ?)`,
        [
          null, // MaDonHang s·∫Ω update sau
          userId || null,
          TongTienHang,
          GiamGia,
          PhiVanChuyen,
          TongThanhToan,
          diaChiGiao,
          soDienThoai,
          hoTen,
          email,
          id_ThanhToan,
          id_VanChuyen,
          MaGiamGia || null,
          ghiChu || null,
          userId ? null : finalSessionId, // session_id ch·ªâ d√πng cho guest
        ]
      );
      const orderId = orderResult.insertId;
      // --- Update MaDonHang chu·∫©n sau khi c√≥ orderId ---
      const MaDonHang = `DH${dateStr}-${orderId}`;
      await connection.execute(
        `UPDATE donhang SET MaDonHang = ? WHERE id = ?`,
        [MaDonHang, orderId]
      );

      // ‚úÖ S·ª¨A: 8. L∆∞u chi ti·∫øt ƒë∆°n h√†ng - Database trigger s·∫Ω t·ª± ƒë·ªông qu·∫£n l√Ω t·ªìn kho
      for (const item of cartItems) {
        // Use correct price (prioritize GiaKhuyenMai)
        const finalPrice = item.GiaKhuyenMai || item.Gia;

        await connection.execute(
          `INSERT INTO chitietdonhang (id_DonHang, id_ChiTietSanPham, SoLuong, GiaBan, ThanhTien)
           VALUES (?, ?, ?, ?, ?)`,
          [
            orderId,
            item.id_ChiTietSanPham,
            item.SoLuong,
            finalPrice,
            finalPrice * item.SoLuong,
          ]
        );
      }

      // ‚úÖ HO√ÄN TO√ÄN B·ªé LOGIC TR·ª™ T·ªíN KHO MANUAL - DATABASE TRIGGER S·∫º X·ª¨ L√ù T·ª∞ ƒê·ªòNG
      // Database trigger `tr_QuanLyTonKhoTheoTrangThaiDonHang` s·∫Ω t·ª± ƒë·ªông:
      // - Tr·ª´ t·ªìn kho khi ƒë∆°n h√†ng chuy·ªÉn t·ª´ tr·∫°ng th√°i 1 (ch·ªù x√°c nh·∫≠n) sang 2 (ƒë√£ x√°c nh·∫≠n)
      // - Ho√†n l·∫°i t·ªìn kho khi ƒë∆°n h√†ng b·ªã h·ªßy (chuy·ªÉn sang tr·∫°ng th√°i 5)

      // 9. X√≥a gi·ªè h√†ng
      if (userId) {
        await connection.execute(`DELETE FROM giohang WHERE id_NguoiDung = ?`, [
          userId,
        ]);
      } else if (finalSessionId) {
        await connection.execute(
          `DELETE FROM giohang WHERE session_id = ? AND id_NguoiDung IS NULL`,
          [finalSessionId]
        );
      }

      await connection.commit();
      connection.release();

      // üéØ G·ª¨I EMAIL X√ÅC NH·∫¨N ƒê·∫∂T H√ÄNG TH√ÄNH C√îNG
      try {
        // L·∫•y th√¥ng tin ƒë∆°n h√†ng ƒë·ªÉ g·ª≠i email
        const orderForEmail = await this.getOrderDetail(orderId);

        await emailService.sendOrderConfirmation(orderForEmail);
      } catch (emailError) {
        // Log l·ªói email nh∆∞ng kh√¥ng ·∫£nh h∆∞·ªüng ƒë·∫øn vi·ªác t·∫°o ƒë∆°n h√†ng
        console.error(
          `‚ùå L·ªói g·ª≠i email x√°c nh·∫≠n cho ƒë∆°n h√†ng #${orderId}:`,
          emailError.message
        );
      }

      // 10. Tr·∫£ l·∫°i chi ti·∫øt ƒë∆°n h√†ng
      return { id: orderId, TongThanhToan, message: "ƒê·∫∑t h√†ng th√†nh c√¥ng" };
    } catch (error) {
      await connection.rollback();
      connection.release();
      throw error;
    }
  }

  async getOrderDetail(orderId) {
    const [orders] = await db.execute(
      `SELECT dh.*, 
              httt.Ten as tenHinhThucThanhToan, 
              htvc.Ten as tenHinhThucVanChuyen,
              IFNULL(mgg.Ma, '') as maGiamGiaText
       FROM donhang dh
       LEFT JOIN hinhthucthanhtoan httt ON dh.id_ThanhToan = httt.id
       LEFT JOIN hinhthucvanchuyen htvc ON dh.id_VanChuyen = htvc.id
       LEFT JOIN magiamgia mgg ON dh.MaGiamGia = mgg.Ma
       WHERE dh.id = ?`,
      [orderId]
    );
    if (orders.length === 0) {
      throw new Error("ƒê∆°n h√†ng kh√¥ng t·ªìn t·∫°i");
    }
    const order = orders[0];
    const [orderDetails] = await db.execute(
      `SELECT ctdh.*, ctsp.id_SanPham, sp.Ten as tenSanPham, sp.HinhAnh,
              kc.Ten as tenKichCo, ms.Ten as tenMauSac
       FROM chitietdonhang ctdh
       JOIN chitietsanpham ctsp ON ctdh.id_ChiTietSanPham = ctsp.id
       JOIN sanpham sp ON ctsp.id_SanPham = sp.id
       JOIN kichco kc ON ctsp.id_KichCo = kc.id
       JOIN mausac ms ON ctsp.id_MauSac = ms.id
       WHERE ctdh.id_DonHang = ?`,
      [orderId]
    );
    order.chiTiet = orderDetails;
    return order;
  }

  // Add method to get guest order by ID and email (for order tracking)
  async getGuestOrderDetail(orderId, email) {
    const [orders] = await db.execute(
      `SELECT dh.*, 
              httt.Ten as tenHinhThucThanhToan, 
              htvc.Ten as tenHinhThucVanChuyen,
              IFNULL(mgg.Ma, '') as maGiamGiaText
       FROM donhang dh
       LEFT JOIN hinhthucthanhtoan httt ON dh.id_ThanhToan = httt.id
       LEFT JOIN hinhthucvanchuyen htvc ON dh.id_VanChuyen = htvc.id
       LEFT JOIN magiamgia mgg ON dh.MaGiamGia = mgg.Ma
       WHERE dh.id = ? AND dh.EmailNguoiNhan = ? AND dh.id_NguoiMua IS NULL`,
      [orderId, email]
    );
    if (orders.length === 0) {
      throw new Error("ƒê∆°n h√†ng kh√¥ng t·ªìn t·∫°i ho·∫∑c email kh√¥ng kh·ªõp");
    }
    const order = orders[0];
    const [orderDetails] = await db.execute(
      `SELECT ctdh.*, ctsp.id_SanPham, sp.Ten as tenSanPham, sp.HinhAnh,
              kc.Ten as tenKichCo, ms.Ten as tenMauSac
       FROM chitietdonhang ctdh
       JOIN chitietsanpham ctsp ON ctdh.id_ChiTietSanPham = ctsp.id
       JOIN sanpham sp ON ctsp.id_SanPham = sp.id
       JOIN kichco kc ON ctsp.id_KichCo = kc.id
       JOIN mausac ms ON ctsp.id_MauSac = ms.id
       WHERE ctdh.id_DonHang = ?`,
      [orderId]
    );
    order.chiTiet = orderDetails;
    return order;
  }

  async cancelOrder(orderId, userId, cancelReason) {
    let connection;
    try {
      connection = await db.getConnection();

      await connection.beginTransaction();

      // S·ª≠a: Ki·ªÉm tra ƒë∆°n h√†ng t·ªìn t·∫°i v√† thu·ªôc v·ªÅ user (ho·∫∑c ƒë∆∞·ª£c t·∫°o b·ªüi user)
      const [orders] = await connection.execute(
        `SELECT * FROM donhang 
         WHERE id = ? AND (id_NguoiMua = ? OR (id_NguoiMua IS NULL AND EmailNguoiNhan = (
           SELECT Email FROM nguoidung WHERE id = ?
         )))`,
        [orderId, userId, userId]
      );

      if (orders.length === 0) {
        throw new Error(
          "ƒê∆°n h√†ng kh√¥ng t·ªìn t·∫°i ho·∫∑c b·∫°n kh√¥ng c√≥ quy·ªÅn h·ªßy ƒë∆°n h√†ng n√†y"
        );
      }

      const order = orders[0];
      if (order.TrangThai !== 1) {
        throw new Error("Ch·ªâ c√≥ th·ªÉ h·ªßy ƒë∆°n h√†ng ·ªü tr·∫°ng th√°i ch·ªù x√°c nh·∫≠n");
      }

      // ‚úÖ S·ª¨A: Ch·ªâ c·∫≠p nh·∫≠t tr·∫°ng th√°i, database trigger s·∫Ω t·ª± ƒë·ªông ho√†n l·∫°i t·ªìn kho
      await connection.execute(
        "UPDATE donhang SET TrangThai = 5, LyDoHuy = ? WHERE id = ?",
        [cancelReason, orderId]
      );

      // ‚úÖ HO√ÄN L·∫†I M√É GI·∫¢M GI√Å (n·∫øu c√≥)
      if (order.MaGiamGia) {
        await connection.execute(
          "UPDATE magiamgia SET SoLuotDaSuDung = SoLuotDaSuDung - 1 WHERE Ma = ?",
          [order.MaGiamGia]
        );
      }

      // Commit transaction
      await connection.commit();

      // Release connection before returning
      connection.release();

      return this.getOrderDetail(orderId);
    } catch (error) {
      // Rollback n·∫øu c√≥ l·ªói
      if (connection) {
        await connection.rollback();
        connection.release();
      }

      console.error("Error canceling order:", error);
      throw error;
    }
  }

  // Add method to cancel guest order
  async cancelGuestOrder(orderId, email, cancelReason) {
    let connection;
    try {
      // L·∫•y connection t·ª´ pool
      connection = await db.getConnection();

      // B·∫Øt ƒë·∫ßu transaction
      await connection.beginTransaction();

      const [orders] = await connection.execute(
        "SELECT * FROM donhang WHERE id = ? AND EmailNguoiNhan = ? AND id_NguoiMua IS NULL",
        [orderId, email]
      );
      if (orders.length === 0) {
        throw new Error("ƒê∆°n h√†ng kh√¥ng t·ªìn t·∫°i ho·∫∑c email kh√¥ng kh·ªõp");
      }

      const order = orders[0];
      if (order.TrangThai !== 1) {
        throw new Error("Kh√¥ng th·ªÉ h·ªßy ƒë∆°n h√†ng ·ªü tr·∫°ng th√°i n√†y");
      }

      // ‚úÖ S·ª¨A: Ch·ªâ c·∫≠p nh·∫≠t tr·∫°ng th√°i, database trigger s·∫Ω t·ª± ƒë·ªông ho√†n l·∫°i t·ªìn kho
      await connection.execute(
        "UPDATE donhang SET TrangThai = 5, LyDoHuy = ? WHERE id = ?",
        [cancelReason, orderId]
      );

      // ‚úÖ HO√ÄN L·∫†I M√É GI·∫¢M GI√Å (n·∫øu c√≥)
      if (order.MaGiamGia) {
        await connection.execute(
          "UPDATE magiamgia SET SoLuotDaSuDung = SoLuotDaSuDung - 1 WHERE Ma = ?",
          [order.MaGiamGia]
        );
      }

      // Commit transaction
      await connection.commit();

      // Release connection before returning
      connection.release();

      return this.getOrderDetail(orderId);
    } catch (error) {
      // Rollback n·∫øu c√≥ l·ªói
      if (connection) {
        await connection.rollback();
        connection.release();
      }

      console.error("Error canceling guest order:", error);
      throw error;
    }
  }

  async getOrderHistory(userId, page = 1, limit = 10) {
    const offset = (page - 1) * limit;
    const [orders] = await db.execute(
      `SELECT dh.*, 
              httt.Ten as tenHinhThucThanhToan, 
              htvc.Ten as tenHinhThucVanChuyen
       FROM donhang dh
       LEFT JOIN hinhthucthanhtoan httt ON dh.id_ThanhToan = httt.id
       LEFT JOIN hinhthucvanchuyen htvc ON dh.id_VanChuyen = htvc.id
       WHERE dh.id_NguoiMua = ?
       ORDER BY dh.NgayDatHang DESC
       LIMIT ? OFFSET ?`,
      [userId, limit, offset]
    );
    for (let order of orders) {
      const [orderDetails] = await db.execute(
        `SELECT ctdh.*, ctsp.id_SanPham, sp.Ten as tenSanPham, sp.HinhAnh
         FROM chitietdonhang ctdh
         JOIN chitietsanpham ctsp ON ctdh.id_ChiTietSanPham = ctsp.id
         JOIN sanpham sp ON ctsp.id_SanPham = sp.id
         WHERE ctdh.id_DonHang = ?`,
        [order.id]
      );
      order.chiTiet = orderDetails;
    }
    const [total] = await db.execute(
      "SELECT COUNT(*) as total FROM donhang WHERE id_NguoiMua = ?",
      [userId]
    );
    return {
      orders,
      pagination: {
        page,
        limit,
        total: total[0].total,
      },
    };
  }

  // ===== ADMIN METHODS =====

  // Get all orders for admin with filtering and pagination
  async getOrdersAdmin(params = {}) {
    const {
      page = 1,
      limit = 20,
      status,
      date,
      search,
      startDate,
      endDate,
    } = params;

    const offset = (page - 1) * limit;
    let whereClause = "WHERE 1=1";
    let queryParams = [];

    // Status filter
    if (status) {
      const statusMap = {
        pending: 1,
        confirmed: 2,
        processing: 3,
        shipping: 4,
        delivered: 4, // C·∫£ shipping v√† delivered ƒë·ªÅu map th√†nh 4
        cancelled: 5, // Cancelled map th√†nh 5, kh√¥ng ph·∫£i 6
      };
      if (statusMap[status]) {
        whereClause += " AND dh.TrangThai = ?";
        queryParams.push(statusMap[status]);
      }
    }

    // Date filter
    if (date) {
      whereClause += " AND DATE(dh.NgayDatHang) = ?";
      queryParams.push(date);
    }

    // Date range filter
    if (startDate && endDate) {
      whereClause += " AND DATE(dh.NgayDatHang) BETWEEN ? AND ?";
      queryParams.push(startDate, endDate);
    }

    // Search filter (by order ID, customer name, email, phone)
    if (search) {
      whereClause += ` AND (
        dh.id LIKE ? OR 
        dh.TenNguoiNhan LIKE ? OR 
        dh.EmailNguoiNhan LIKE ? OR 
        dh.SDTNguoiNhan LIKE ?
      )`;
      const searchTerm = `%${search}%`;
      queryParams.push(searchTerm, searchTerm, searchTerm, searchTerm);
    }

    // Get orders with pagination
    const ordersQuery = `
      SELECT 
        dh.*,
        httt.Ten as paymentMethod,
        htvc.Ten as shippingMethod,
        dh.TrangThai as TrangThai,
        CASE dh.TrangThai
          WHEN 1 THEN 'pending'
          WHEN 2 THEN 'confirmed' 
          WHEN 3 THEN 'shipping'
          WHEN 4 THEN 'delivered'
          WHEN 5 THEN 'cancelled'
          ELSE 'pending'
        END as status
      FROM donhang dh
      LEFT JOIN hinhthucthanhtoan httt ON dh.id_ThanhToan = httt.id
      LEFT JOIN hinhthucvanchuyen htvc ON dh.id_VanChuyen = htvc.id
      ${whereClause}
      ORDER BY dh.NgayDatHang DESC
      LIMIT ? OFFSET ?
    `;

    const [orders] = await db.execute(ordersQuery, [
      ...queryParams,
      limit,
      offset,
    ]);

    // Transform orders for frontend
    const transformedOrders = orders.map((order) => ({
      id: order.id,
      customerName: order.TenNguoiNhan,
      customerEmail: order.EmailNguoiNhan,
      customerPhone: order.SDTNguoiNhan,
      total: order.TongThanhToan,
      TrangThai: order.TrangThai, // ‚úÖ Tr·∫£ v·ªÅ s·ªë tr·∫°ng th√°i
      status: order.status, // ‚úÖ Gi·ªØ l·∫°i string cho backward compatibility
      createdAt: order.NgayDatHang,
      paymentMethod: order.paymentMethod,
      shippingMethod: order.shippingMethod,
      shippingAddress: order.DiaChiNhan,
      note: order.GhiChu,
      discount: order.GiamGia,
      shippingFee: order.PhiVanChuyen,
      subtotal: order.TongTienHang,
    }));

    // Get total count for pagination
    const countQuery = `SELECT COUNT(*) as total FROM donhang dh ${whereClause}`;
    const [countResult] = await db.execute(countQuery, queryParams);
    const total = countResult[0].total;

    return {
      orders: transformedOrders,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit),
      },
    };
  }

  // Get order detail for admin
  async getOrderDetailAdmin(orderId) {
    const [orders] = await db.execute(
      `SELECT 
        dh.*,
        httt.Ten as paymentMethod,
        htvc.Ten as shippingMethod,
        dh.TrangThai as TrangThai,
        CASE dh.TrangThai
          WHEN 1 THEN 'pending'
          WHEN 2 THEN 'confirmed' 
          WHEN 3 THEN 'shipping'
          WHEN 4 THEN 'delivered'
          WHEN 5 THEN 'cancelled'
          ELSE 'pending'
        END as status
       FROM donhang dh
       LEFT JOIN hinhthucthanhtoan httt ON dh.id_ThanhToan = httt.id
       LEFT JOIN hinhthucvanchuyen htvc ON dh.id_VanChuyen = htvc.id
       WHERE dh.id = ?`,
      [orderId]
    );

    if (orders.length === 0) {
      throw new Error("ƒê∆°n h√†ng kh√¥ng t·ªìn t·∫°i");
    }

    const order = orders[0];

    // Get order items
    const [orderItems] = await db.execute(
      `SELECT 
        ctdh.*,
        sp.Ten as name,
        sp.HinhAnh,
        kc.Ten as size,
        ms.Ten as color,
        CONCAT(kc.Ten, ' / ', ms.Ten) as variant
       FROM chitietdonhang ctdh
       JOIN chitietsanpham ctsp ON ctdh.id_ChiTietSanPham = ctsp.id
       JOIN sanpham sp ON ctsp.id_SanPham = sp.id
       JOIN kichco kc ON ctsp.id_KichCo = kc.id
       JOIN mausac ms ON ctsp.id_MauSac = ms.id
       WHERE ctdh.id_DonHang = ?`,
      [orderId]
    );

    // Parse product images
    const items = orderItems.map((item) => {
      let image = null;
      try {
        if (item.HinhAnh) {
          const imageData = JSON.parse(item.HinhAnh);
          image = imageData.anhChinh || null;
        }
      } catch (error) {
        console.error("Error parsing product image:", error);
      }

      return {
        id: item.id,
        name: item.name,
        image: image,
        variant: item.variant,
        size: item.size,
        color: item.color,
        quantity: item.SoLuong,
        price: item.GiaBan,
        total: item.ThanhTien,
      };
    });

    // Transform order for frontend
    return {
      id: order.id,
      customerName: order.TenNguoiNhan,
      customerEmail: order.EmailNguoiNhan,
      customerPhone: order.SDTNguoiNhan,
      shippingAddress: order.DiaChiNhan,
      paymentMethod: order.paymentMethod,
      shippingMethod: order.shippingMethod,
      TrangThai: order.TrangThai, // ‚úÖ Tr·∫£ v·ªÅ s·ªë tr·∫°ng th√°i
      status: order.status, // ‚úÖ Gi·ªØ l·∫°i string cho backward compatibility
      createdAt: order.NgayDatHang,
      subtotal: order.TongTienHang,
      discount: order.GiamGia,
      shippingFee: order.PhiVanChuyen,
      total: order.TongThanhToan,
      note: order.GhiChu,
      voucherCode: order.MaGiamGia,
      items: items,
    };
  }

  // Update order status by admin
  async updateOrderStatusAdmin(orderId, status, note = null) {
    const connection = await db.getConnection();

    try {
      await connection.beginTransaction();

      // Map frontend status to database status - S·ª¨A CHO ƒê√öNG DATABASE SCHEMA
      const statusMap = {
        pending: 1,
        confirmed: 2,
        processing: 3, // ƒêang x·ª≠ l√Ω -> map th√†nh 3 (ƒëang giao)
        shipping: 4, // ƒêang giao -> map th√†nh 4 (ƒë√£ giao)
        delivered: 4, // ƒê√£ giao -> map th√†nh 4
        cancelled: 5, // ƒê√£ h·ªßy -> map th√†nh 5
      };

      const dbStatus = statusMap[status];
      if (!dbStatus) {
        throw new Error("Tr·∫°ng th√°i kh√¥ng h·ª£p l·ªá");
      }

      // Check if order exists and get full order details for email
      const [orders] = await connection.execute(
        `SELECT dh.*, 
                httt.Ten as tenHinhThucThanhToan, 
                htvc.Ten as tenHinhThucVanChuyen,
                IFNULL(mgg.Ma, '') as maGiamGiaText
         FROM donhang dh
         LEFT JOIN hinhthucthanhtoan httt ON dh.id_ThanhToan = httt.id
         LEFT JOIN hinhthucvanchuyen htvc ON dh.id_VanChuyen = htvc.id
         LEFT JOIN magiamgia mgg ON dh.MaGiamGia = mgg.Ma
         WHERE dh.id = ?`,
        [orderId]
      );

      if (orders.length === 0) {
        throw new Error("ƒê∆°n h√†ng kh√¥ng t·ªìn t·∫°i");
      }

      const order = orders[0];
      const oldStatus = order.TrangThai;

      // Get order details for email
      const [orderDetails] = await connection.execute(
        `SELECT ctdh.*, ctsp.id_SanPham, sp.Ten as tenSanPham, sp.HinhAnh,
                kc.Ten as tenKichCo, ms.Ten as tenMauSac
         FROM chitietdonhang ctdh
         JOIN chitietsanpham ctsp ON ctdh.id_ChiTietSanPham = ctsp.id
         JOIN sanpham sp ON ctsp.id_SanPham = sp.id
         JOIN kichco kc ON ctsp.id_KichCo = kc.id
         JOIN mausac ms ON ctsp.id_MauSac = ms.id
         WHERE ctdh.id_DonHang = ?`,
        [orderId]
      );

      // Prepare order data for email
      const orderDataForEmail = {
        ...order,
        chiTiet: orderDetails,
      };

      // ‚úÖ S·ª¨A: Ch·ªâ c·∫≠p nh·∫≠t tr·∫°ng th√°i, database trigger s·∫Ω t·ª± ƒë·ªông qu·∫£n l√Ω t·ªìn kho
      await connection.execute(
        `UPDATE donhang 
         SET TrangThai = ?, 
             GhiChu = CASE 
               WHEN ? IS NOT NULL THEN CONCAT(IFNULL(GhiChu, ''), '\n[Admin] ', ?)
               ELSE GhiChu 
             END,
             NgayCapNhat = NOW()
         WHERE id = ?`,
        [dbStatus, note, note, orderId]
      );

      // ‚úÖ HO√ÄN L·∫†I M√É GI·∫¢M GI√Å N·∫æU H·ª¶Y ƒê∆†N H√ÄNG
      if (status === "cancelled" && oldStatus !== 5 && order.MaGiamGia) {
        await connection.execute(
          "UPDATE magiamgia SET SoLuotDaSuDung = SoLuotDaSuDung - 1 WHERE Ma = ?",
          [order.MaGiamGia]
        );
      }

      await connection.commit();
      connection.release();

      // üéØ G·ª¨I EMAIL T·ª∞ ƒê·ªòNG KHI C·∫¨P NH·∫¨T TR·∫†NG TH√ÅI
      // Ch·ªâ g·ª≠i email n·∫øu tr·∫°ng th√°i th·ª±c s·ª± thay ƒë·ªïi v√† c√≥ email kh√°ch h√†ng
      if (oldStatus !== dbStatus && order.EmailNguoiNhan) {
        try {
          await emailService.sendOrderStatusUpdate(
            orderDataForEmail,
            status,
            note
          );
        } catch (emailError) {
          // Log l·ªói email nh∆∞ng kh√¥ng throw ƒë·ªÉ kh√¥ng ·∫£nh h∆∞·ªüng ƒë·∫øn vi·ªác c·∫≠p nh·∫≠t ƒë∆°n h√†ng
          console.error(
            `‚ùå L·ªói g·ª≠i email cho ƒë∆°n h√†ng #${orderId}:`,
            emailError.message
          );

          // C√≥ th·ªÉ l∆∞u log v√†o database ƒë·ªÉ theo d√µi
          try {
            await db.execute(
              `INSERT INTO email_logs (order_id, email_type, recipient, status, error_message, created_at) 
               VALUES (?, ?, ?, 'failed', ?, NOW())`,
              [
                orderId,
                "order_status_update",
                order.EmailNguoiNhan,
                emailError.message,
              ]
            );
          } catch (logError) {
            console.error("L·ªói ghi log email:", logError.message);
          }
        }
      }

      // Return updated order detail
      return await this.getOrderDetailAdmin(orderId);
    } catch (error) {
      await connection.rollback();
      connection.release();
      throw error;
    }
  }

  // Get order statistics for admin dashboard
  async getOrderStats(period = "week") {
    try {
      // Get total orders count
      const [totalOrders] = await db.execute(
        "SELECT COUNT(*) as total FROM donhang"
      );

      // Get orders by status
      const [statusStats] = await db.execute(`
        SELECT 
          TrangThai,
          COUNT(*) as count,
          CASE TrangThai
            WHEN 1 THEN 'pending'
            WHEN 2 THEN 'confirmed' 
            WHEN 3 THEN 'processing'
            WHEN 4 THEN 'shipping'
            WHEN 5 THEN 'cancelled'
            ELSE 'unknown'
          END as status
        FROM donhang 
        GROUP BY TrangThai
      `);

      // Get revenue stats
      const [revenueStats] = await db.execute(`
        SELECT 
          SUM(TongThanhToan) as totalRevenue,
          AVG(TongThanhToan) as averageOrderValue,
          COUNT(*) as totalOrders
        FROM donhang 
        WHERE TrangThai = 5
      `);

      // Get recent orders trend (last 7 days)
      const [trendStats] = await db.execute(`
        SELECT 
          DATE(NgayDatHang) as date,
          COUNT(*) as orders,
          SUM(TongThanhToan) as revenue
        FROM donhang 
        WHERE NgayDatHang >= DATE_SUB(NOW(), INTERVAL 7 DAY)
        GROUP BY DATE(NgayDatHang)
        ORDER BY date ASC
      `);

      return {
        totalOrders: totalOrders[0].total,
        statusBreakdown: statusStats,
        revenue: {
          total: revenueStats[0].totalRevenue || 0,
          average: revenueStats[0].averageOrderValue || 0,
          completedOrders: revenueStats[0].totalOrders || 0,
        },
        trend: trendStats,
      };
    } catch (error) {
      console.error("Error getting order stats:", error);
      throw error;
    }
  }
}

module.exports = new OrderService();
